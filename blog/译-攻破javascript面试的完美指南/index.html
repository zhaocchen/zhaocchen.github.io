<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.72">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="元气の小岛 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="元气の小岛 Blog Atom Feed"><title data-react-helmet="true">译-攻破javascript面试的完美指南 | 元气の小岛</title><meta data-react-helmet="true" property="og:title" content="译-攻破javascript面试的完美指南 | 元气の小岛"><meta data-react-helmet="true" name="description" content="攻破javascript面试的完美指南(开发者视角)"><meta data-react-helmet="true" property="og:description" content="攻破javascript面试的完美指南(开发者视角)"><meta data-react-helmet="true" property="og:url" content="https://zhaocchen.github.io/blog/译-攻破javascript面试的完美指南"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://zhaocchen.github.io/blog/译-攻破javascript面试的完美指南"><link data-react-helmet="true" rel="alternate" href="https://zhaocchen.github.io/blog/译-攻破javascript面试的完美指南" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://zhaocchen.github.io/blog/译-攻破javascript面试的完美指南" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.3844cf23.css">
<link rel="preload" href="/assets/js/styles.c8a50b90.js" as="script">
<link rel="preload" href="/assets/js/runtime~main.e3a5b9b1.js" as="script">
<link rel="preload" href="/assets/js/main.7b4fe14a.js" as="script">
<link rel="preload" href="/assets/js/1.8bed503c.js" as="script">
<link rel="preload" href="/assets/js/2.9d62b940.js" as="script">
<link rel="preload" href="/assets/js/3.eab559b0.js" as="script">
<link rel="preload" href="/assets/js/ccc49370.76f47225.js" as="script">
<link rel="preload" href="/assets/js/694019e6.819dc3e7.js" as="script">
<link rel="preload" href="/assets/js/81561cc0.419d6f73.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/avatar.jpeg" alt="元气の小岛" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/avatar.jpeg" alt="元气の小岛" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">元气の小岛</strong></a><a class="navbar__item navbar__link" href="/docs/">专栏</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zhaocchen" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_GrZ2"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/avatar.jpeg" alt="元气の小岛" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/avatar.jpeg" alt="元气の小岛" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">元气の小岛</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">专栏</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/blog">博客</a></li><li class="menu__list-item"><a href="https://github.com/zhaocchen" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--3"><div class="sidebar_2ahu thin-scrollbar"><h3 class="sidebarItemTitle_2hhb">All our posts</h3><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/git">git新命令及别名</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2021/08/06/weekly253">weekly253</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly249">weekly249</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly248">weekly248</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly247">weekly247</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly246">weekly246</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/track">什么是埋点</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly245">weekly245</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly244">weekly244</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly242">weekly242</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly241">weekly241</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/weekly240">新起点的思考</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/如何将webpack3升级至webpack4">如何将webpack3升级至webpack4</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/如何使用parcel实现零配置打包">如何使用parcel实现零配置打包</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/如何实现vue多页面">如何实现vue多页面</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/译-ECMAScript2020">译-ECMAScript2020</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/ES6迭代器">ES6迭代器</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/如何实现文本渐变">如何实现文本渐变</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/最近使用的几种图标字体库">最近使用的几种图标字体库</a></li><li class="sidebarItem_2UVv"><a aria-current="page" class="sidebarItemLink_1RT6 sidebarItemLinkActive_12pM" href="/blog/译-攻破javascript面试的完美指南">译-攻破javascript面试的完美指南</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/译-雅虎35条军规">译-提升页面性能的最好实践(雅虎35条军规)</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/JavaScript中&amp;&amp;与&amp;区别">JavaScript中&amp;&amp;与&amp;区别</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/如何使用hexo搭建个人博客">如何使用hexo搭建个人博客</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/hello-world">Hello</a></li></ul></div></div><main class="col col--7"><article><header><h1 class="margin-bottom--sm blogPostTitle_GeHD">译-攻破javascript面试的完美指南</h1><div class="margin-vert--md"><time datetime="2018-10-20T00:00:00.000Z" class="blogPostDate_fNvV">October 20, 2018 · 8 min read</time></div><div class="avatar margin-vert--md"><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/zhaocchen" target="_blank" rel="noopener noreferrer">Zhao chen</a></h4><small class="avatar__subtitle"></small></div></div></header><div class="markdown"><p>攻破javascript面试的完美指南(开发者视角)</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="0-前言"></a>0. 前言<a class="hash-link" href="#0-前言" title="Direct link to heading">#</a></h2><blockquote><p>本文适合有一定js基础的前端开发人员阅读。原文是我google时无意发现的， 被一些知识点清晰的解析所打动， 决定翻译并记录下来。这个过程断续进行了两个月， 期间工作遇到的部分疑问也在文中找到了答案。这篇好的文章值得被推荐。</p></blockquote><blockquote><p>说明：因为外网的缘故， 原文中的一些视频连接并没有贴出。部分采用意译， 示例代码有少许差别。由于英文水平有限， 欢迎指出错误和批评。</p></blockquote><p>  为了向你说明js面试的复杂性， 尝试给出代码段的输出。 </p><p> console.log(2.0 == &#x27;2&#x27; == new Boolean(true) == &#x27;1&#x27;)
// true</p><p>十有八九的会给出false， 其实运行结果是true。</p><p>JavaScript是难的。 如果太聪明面试问类似问题， 我们也无可奈何。 但是什么是我们应该准备的呢？深入学习这十一个基本知识点，有助于你的JS面试。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1熟悉js函数"></a>1.熟悉js函数<a class="hash-link" href="#1熟悉js函数" title="Direct link to heading">#</a></h2><p>function 是JavaScript的精髓。不同于其他语言， 在js中， 一个函数可以分配成一个变量， 作为参数传递给其他函数也可以作为其他函数的返回值。</p><p> console.log(square1(5));
/<em> ... </em>/
function square1(n) { return n * n; }
// 25</p><p> console.log(square2(5));
var square2 = function(n) {
return n * n;
}
// square2 is not a function</p><p>JS中， 如果你把函数定义为变量， 变量的名字会被提升， 但是JS执行到它的定义才能被访问。</p><p>你可能在一些代码中频繁的见到如下代码。</p><p> var simpleLibrary = function() {
var simpleLibrary = {
a: 0,
b: 0,
add: function(a, b) {
return a + b;
},
subtract: function(a, b) {
return a - b;<br>
}
}
return simpleLibrary;
}();</p><p>一个函数变量中变量和函数被分装， 可以避免全局变量污染。 从JQuery到Lodash的库采用这用技术提供$、_等</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2熟悉bind、apply和call"></a>2.熟悉bind、apply和call<a class="hash-link" href="#2熟悉bind、apply和call" title="Direct link to heading">#</a></h2><p>你可能在所有常用库中看到过这三个函数。它们允许局部套用， 我们可以把功能组合到不同的函数。一个优秀的js开发者可以随时告诉你关于这三个函数。</p><p>首先， 这些都是函数的原型方法去改变行为来实现一些功能。依据JS开发者Chad, 用途描述如下：</p><blockquote><p>当你想要函数在特定上下文中调用，使用.bind()， 很适用于事件。
当你期望立即调用函数并修改上下文， 使用.call()或.apply()</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="一个应急调用实例"></a>一个应急调用实例<a class="hash-link" href="#一个应急调用实例" title="Direct link to heading">#</a></h3><p>解释一下上述描述。假设你的数学老师要求你创建一个库并提交。你写了一个可以计算圆周长和面积的抽象库。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var mathLib = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    pi: 3.14,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    area: function(r) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return this.pi * r * r;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    circumference: function(r) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return 2 * this.pi * r;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>你把函数库提交给老师。现在是时间提交被称为计算库的代码。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">mathLib.area(2) // 12.56</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>当你提交第二个代码实例时， 你发现指南中老师要求你常量pi精确到小数点后5位数。你使用的是3.14， 不是3.14159。现在由于最后期限已过你没有机会提交库。 JS call函数可以帮你。 只需要调用你的代码如下。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">mathLib.area.call({pi: 3.14159}, 2) //    12.56636</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>加入你注意到call函数具有两个参数。</p><ul><li>上下文</li><li>函数参数</li></ul><p>在area函数中， 上下文是对象被关键词this代替。后面的参数作为函数参数被传递。 如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var cylinder = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    pi: 3.14,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    volume: function(r, h) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return this.pi * r * r * h;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    },</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>call 调用如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cylinder.volume.call({pi: 3.14159}, 2, 6); //    75.39815999999999</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>你看到这些函数的参数在上下文对象后被传递了吗？</p><p>Apply 是相似的， 除了函数参数以列表的方式被传递。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">cylinder.volume.apply({ pi: 3.14159 }, [2, 6]); //    75.39815999999999</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>你知道call的用法， apply用法反之亦然。 那么 ， bind的用法呢？</p><p>Bind函数的用途呢？它允许我们将上下文注入一个函数， 该函数返回一个带有更新上下文的新函数。这意味着， 这个变量将是用户提供的变量。当和JS事件一起运行时这是非常有用的。</p><blockquote><p>你应该熟悉在JS中使用这三个函数去组合功能</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3熟悉js作用域闭包"></a>3.熟悉js作用域(闭包)<a class="hash-link" href="#3熟悉js作用域闭包" title="Direct link to heading">#</a></h2><p>JS作用域是一个潘多拉魔盒。数以百计的面试难题有这个概念构成。 有三种作用域：</p><ul><li>全局作用域</li><li>本地/函数作用域</li><li>块级作用域(ES6引进)</li></ul><p>全局作用域是我们通常做的那样：</p><p> x = 10;
function Foo() {
console.log(x); // Prints 10
}
Foo()</p><p>函数作用域生效当你定义一个局部变量时：</p><p> pi = 3.14;
function circumference(radius) {<br>
pi = 3.14159;
console.log(2 <em> pi </em> radius); // Prints &quot;12.56636&quot; not &quot;12.56&quot;
}
circumference(2);</p><p>ES16标准介绍过新块级作用域，限制一个变量作用域带给定的括号块。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var a = 10;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Foo() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (true) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        let a = 4;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(a);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Foo() //    10, 因为关键词key</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>函数和条件都被视为块。以上例子应该给出4，因为条件声明已经生效。但是ES6销毁了块级变量的作用域，作用域进入全局。</p><p>现在来自神奇的作用域。它可以通过闭包实现。JS闭包是一个返回另一个函数的函数。</p><p>如果有人要求你，实现输入一个字符串并逐次返回字符。如果给出一个新的字符串， 需要替换旧字符串。他被简单成为生成器。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function generator(input) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var index = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        next: function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if (index &lt; input.length) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                index += 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return input[index - 1];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return &quot;&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var mygenerator = generator(&#x27;hello&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">mygenerator.next(); //    &quot;h&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">mygenerator.next(); //    &quot;e&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">mygenerator = generator(&#x27;word&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">mygenerator.next(); //    &quot;w&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>此时， 作用域扮演一个重要的角色。一个闭包是返回另一个函数和包裹数据的一个函数。以上字符串生成器便是一个闭包。index的值在多个函数调用中被保存。内部函数可以访问父级函数中定义的变量。这是一个不同的作用域。假设你在二级函数中定义了一个函数， 它可以访问所有父级变量。</p><blockquote><p>JS作用域会给你带来很多问题， 彻底理解它。</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4熟悉this全局域、函数域、对象域"></a>4.熟悉this(全局域、函数域、对象域)<a class="hash-link" href="#4熟悉this全局域、函数域、对象域" title="Direct link to heading">#</a></h2><p>JS中， 我们经常把函数和对象组合。假设在浏览器中， 在全局上下文中它涉及window对象。我的意思是， 如果你现在打开浏览器控制台输入this， 改制为true</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">this === window //    true</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>当程序的上下文和作用域改变时， this随之发生改变。现在观察this在一个局部上下文中：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Foo() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(this.a);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Foo() //    undefined</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var food = { a: &#x27;hello--&#x27; };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Foo.call(food); //    hello--</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>你可以尝试预测一下输出：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Roo(){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(this); // prints {}?</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Roo() //    Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>不，你还没有获胜。因为this此时是一个全局对象。记住， 无论父级作用域是什么， 它都讲被它的孩子继承。因此， 它打印出了window对象。我们讨论的三个方法实际上用于设置this对象。</p><p>现在，this的最后一个类型。在对象中的this, 如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var person = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    name: &#x27;Tom&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    age: 26,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    get identity() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return { </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            who: this.name,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            howOld: this.age</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>我仅仅使用getter语法， 它是一个可以作为变量调用的函数。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">person.identity; //    {who: &quot;Tom&quot;, howOld: 26}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>因此， 这实际是对象自己。this正如我们前面所提到的不同地方的表现不同。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5熟悉对象freeze、seal属性"></a>5.熟悉对象(freeze、seal属性)<a class="hash-link" href="#5熟悉对象freeze、seal属性" title="Direct link to heading">#</a></h2><p>可以通过以下方式创建对象：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var marks = {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var marks = new Object();</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>我们大多是熟悉的对象如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var marks  = { physics: 98, maths: 95, chemistry: 91 };</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>它是一个键值对存储键、值。JS 对象具备的一个特殊属性， 把任何东西可以视为value。这意味着， 我们可以把一个数组、对象、函数作为value来存储。有何不可呢？</p><p>你借助JSON的stringify、parse防范可以轻松的把对象转成一个JSON， 相应的可以再转成对象。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">JSON.stringify(marks); //    &quot;{&quot;physics&quot;:98,&quot;maths&quot;:95,&quot;chemistry&quot;:91}&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">JSON.parse(&#x27;{&quot;physics&quot;:98,&quot;maths&quot;:95,&quot;chemistry&quot;:91}&#x27;); //    {physics: 98, maths: 95, chemistry: 91}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>因此，对于对象你有了解一些什么呢。使用Object.keys很容易迭代对象</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var highScore = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (k of Object.keys(marks)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (marks[k] &gt; highScore) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        highScore = marks[k];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(highScore); //    98</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Object.values 以数组的方式返回对象的值。</p><p>其他重要的对象函数：</p><ul><li>Object.prototype(object)</li><li>Object.freeze(function)</li><li>Object.seal(function)</li></ul><p>Object.prototype提供更多可以应用的重要函数。如下：</p><p>Object.prototype.hasOwnProperty 用于发现一个对象是否存在一个原型或键。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">marks.hasOwnProperty(&#x27;physics&#x27;); //    true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">marks.hasOwnProperty(&#x27;greek&#x27;); //    false</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Object.prototype.instanceof 评估一个对象是否是特定原型的类型。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Car(make, model, year) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.make = make;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.model = model;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.year = year;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var newCar = new Car(&#x27;Jack&#x27;, &#x27;City&#x27;, &#x27;2008&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(newCar instanceof Car) //    true</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>现在介绍其它两个函数。Object.freeze 允许我们冻结一个对象， 使得存在的属性不能被改变。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var marks = {physics: 98, math: 95, chemisty: 91}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">finalizedMarks = Object.freeze(marks); //    {physics: 98, maths: 95, chemistry: 91}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">finalizedMarks[&#x27;physics&#x27;] = 86; </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(marks); //    {physics: 98, maths: 95, chemistry: 91}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>代码中， physics属相并未被改变。我们可以使用Object.isFrozen来判断，给定对象是否被冻结</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Object.isFrozen(finalizedMarks); //    true</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Object.seal 与freeze有细微差别。前者允许配置属性， 但是不允许添加或删除属性。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var marks = {physics: 98, math: 95, chemisty: 91}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Object.seal(marks); //    {physics: 98, math: 95, chemisty: 91}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">delete marks.chemisty //    false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">marks.physics = 95;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(marks); //    {physics: 95, math: 95, chemisty: 91}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">marks.greek = 86;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(marks); //    {physics: 95, math: 95, chemisty: 91}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>同样， 可以借助Object.isSealed判断对象是否被密封。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Object.isSealed(marks) //    true</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="6熟悉原型继承"></a>6.熟悉原型继承<a class="hash-link" href="#6熟悉原型继承" title="Direct link to heading">#</a></h2><p>在传统的js中隐藏着继承的概念， 使用原型技术。你在ES5、ES6中看到的所有new class语法仅仅是底层原型OOP的表层。使用js函数创建一个class.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var animalGroups = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    MAMMAL: 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    REPTILE: 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    AMPHIBIAN: 3,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    INVERTEBRATE: 4,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Animal(name, type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.name = name;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.type = type;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var dog = new Animal(&quot;dog&quot;, animalGroups.MAMMAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(dog); //    Animal { name: &#x27;dog&#x27;, type: 1 }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var crocodile = new Animal(&quot;crocodile&quot;, animalGroups.REPTILE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(crocodile); //    Animal { name: &#x27;crocodile&#x27;, type: 2 }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>此时， 我们创建一个类（使用关键词new）。可以使用如下方式对class追加方法。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Animal.prototype.shout = function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(this.name+&#x27;is&#x27;+this.sound+&#x27;ing...&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>你可能有疑问。现在class中没有sound属性。是的。定义一个sound属性几乎没有可能，可以由继承它的子类进行传递。</p><p>js中， 如下实现继承。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function Dog(name, type) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Animal.call(this, name, type);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.sound = &#x27;bow&#x27;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// console.log(Dog); // [Function: Dog]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>定义一个特殊的函数Dog。为了继承Animal， 需要call传递this和其他参数。如下方式实例化一个Jack。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var pet = new Dog(&#x27;Jack&#x27;, animalGroups.MAMMAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(pet);   // Dog { name: &#x27;Jack&#x27;, type: 1, sound: &#x27;bow&#x27; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(pet instanceof Dog); // true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(pet instanceof Animal); // false</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>我们不能在子函数中分配name和type，但是可以调用超级函数Animal并设置属性。。pet拥有其父的（name, type）属性。是否也继承了方法。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">pet.shout(); // is not a function</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>为什么没有继承呢？  因为不能继承父class的方法。如何补救？</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Dog.prototype = Object.create(Animal.prototype);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var pig = new Dog(&#x27;Jack&#x27;, animalGroups.MAMMAL);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">pig.shout(); // Jackisbowing...</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>现在shout方法是有效的。Object.constructor函数检查对象的class.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(pig.constructor); // [Function: Animal]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>检查pig的结果。Animal是父类。这是因为Dog的类</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(Dog.prototype.constructor); // [Function: Animal]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>输出是Aimal。我们应该设置Dog为其本身， 这样类的所有实例(对象)都应该在类所属的地方给出正确的类名。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Dog.prototype.constructor = Dog;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(Dog.prototype.constructor); // [Function: Dog]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>关于原型继承， 我们应该记住以下几条：</p><ul><li>class 属性使用this绑定</li><li>class 方法使用prototype对象来绑定</li><li>为了继承原型， 使用call函数传递this</li><li>为了继承方法, 使用Object.create连接父和子的原型</li><li>通设置子class构造函数本身为获取正确的标识。</li></ul><p>注意：即使使用新的class语法， 这些事情也会发生。了解这些对你熟悉js有帮助。</p><blockquote><p>js中， call函数和原型对象提供继承</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="7熟悉callback和promise"></a>7.熟悉callback和promise<a class="hash-link" href="#7熟悉callback和promise" title="Direct link to heading">#</a></h2><p>callback 是 一个I/O执行完毕后执行的函数。一个耗时的I/O操作会阻塞代码， 因此在Python/Ruby不被允许。但是js中， 由于允许异步执行， 我们可以提供异步函数来回调。这个例子是由浏览器到服务器的AJAX(XMLHettpRequest)调用，由鼠标、键盘事件生成。如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function reqListener() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    console.log(this.responseText);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var req = new XMLHttpRequest();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">req.addEventListener(&#x27;load&#x27;, reqListenter);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">req.open(&#x27;GET&#x27;, &#x27;http://www.example.org/example.txt&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">req.send();</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>其中， reqListenter是GET请求成功后的回调函数。</p><p>Promise 是回调函数的优雅的封装， 使得我们优雅的实现异步代码。此时， 不再过多讨论promise, 虽然对于熟悉Js及其重要。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="8熟悉正则表达"></a>8.熟悉正则表达<a class="hash-link" href="#8熟悉正则表达" title="Direct link to heading">#</a></h2><p>创建正则表达式，有如下两种方式：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var re = /ar/;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var re = new RegExp(&#x27;ar&#x27;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>以上正则用于匹配字符串。一旦正则已经定义， 可以使用exec函数匹配字符串。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">re.exec(&#x27;car&#x27;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">re.exec(&#x27;cab&#x27;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>存在复杂的符号， 来实现复杂的正则表达式。</p><ul><li>字符正则：\w-字母数字， \d-数字， \D-没有数字</li><li>字符正则：[x-y]x-y区间， <sup id="fnref-x"><a href="#fn-x" class="footnote-ref">x</a></sup>没有x</li><li>数量正则：+至少一个、?没或多个、*多个</li><li>边界正则，^开始、$结尾</li></ul><p>例子如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/\d/.exec(&#x27;qwe&#x27;) // null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/\d/.exec(&#x27;2344&#x27;) // [&quot;2&quot;, index: 0, input: &quot;2344&quot;, groups: undefined]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/\d/.exec(&#x27;2cc4&#x27;) // [&quot;2&quot;, index: 0, input: &quot;2cc4&quot;, groups: undefined]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/e+/.exec(&#x27;qwe&#x27;) // [&quot;e&quot;, index: 2, input: &quot;qwe&quot;, groups: undefined]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">[^x]/.exec(&#x27;xcc4&#x27;)  // [&quot;c&quot;, index: 1, input: &quot;xcc4&quot;, groups: undefined]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/^q/.exec(&#x27;qwe&#x27;) //[&quot;q&quot;, index: 0, input: &quot;qwe&quot;, groups: undefined]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/e$/.exec(&#x27;qwe&#x27;) // [&quot;e&quot;, index: 2, input: &quot;qwe&quot;, groups: undefined]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>除了exec， 还有match、search，以及replace可以返回一个字符串使用正则表达式。但是主体是一个字符串。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&#x27;hello 12345&#x27;.match(/\d/) // [&quot;1&quot;, index: 6, input: &quot;hello 12345&quot;, groups: undefined]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&#x27;hello 12345&#x27;.replace(/1/, &#x27;c&#x27;) // &quot;hello c2345&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>正则是个重要的话题， 对于想要简单解决复杂问题的开发人员来说。</p><blockquote><p>正则不单单属于js， 你也可以经常在其他语言中见到</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="9熟悉map、reduce和filter"></a>9.熟悉map、reduce和filter<a class="hash-link" href="#9熟悉map、reduce和filter" title="Direct link to heading">#</a></h2><p>函数式编程是最近讨论的话题。许多编程语言的新版本开始包括lambdas等概念(如：java&gt;7)。 js中， 支持函数式结构已经有很长一段时间。此处， 有三个函数需要我们深入学习。数学函数获取输出并给出返回。一个纯正的函数总是依据输入给出返回，如下讨论的函数属于此类函数。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="91-map"></a>9.1 map<a class="hash-link" href="#91-map" title="Direct link to heading">#</a></h3><p>map函数在js数组中可用。使用这个函数， 我们通过对每一个元素进行转换来获取一个新的数组。一般的js数组map操作如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">arr.map((elem){</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    process(elem);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return processedValue;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}); // return a new array</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>假设，我们最近工作的串行键不需要字符。 我们需要移除。可以使用map去执行相同的操作从而获取结果数字，而不是通过迭代和发现的方式移除字符。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var data = [&#x27;2345-34r&#x27;, &#x27;2e345-211&#x27;, &#x27;543-67i4&#x27;, &#x27;346-598&#x27;];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var re = /[a-z A-Z]/;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var cleanedData = data.map((elem) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return elem.replace(re, &#x27;&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">console.log(cleanedData); // [&quot;2345-34&quot;, &quot;2345-211&quot;, &quot;543-674&quot;, &quot;346-598&quot;]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>注意：使用es6的箭头函数语法来定义函数</p><p>map接受一个作为参数的函数， 此函数接受一个来自数组的参数。我们需要返回一个处理过的元素， 并应用于数组中的所有元素。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="92-reduce"></a>9.2 reduce<a class="hash-link" href="#92-reduce" title="Direct link to heading">#</a></h3><p>reduce函数将一个给定的列表归纳出一个返回。我们通过迭代数组执行相同的操作， 并保存中间结果到一个变量中。此处是一个更简洁的方式进行处理。js的reduce一般使用语法如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">arr.reduce((accumulator, value, index) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    process(accumulator, value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return accumulator;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}, initAccumulator);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>initAccumulator, 累加器的初始值</li><li>accumulator， 累加器用于存储中间值和结果值</li><li>value， 对组对应的元素</li><li>index， 数组对应的索引号</li></ul><p>reduce 的一个实际应用是将一个数组扁平化， 将内部数组转化为单个数组， 如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var arr = [[1, 2], [3, 4], [5, 6]]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var flattenedArray = [1, 2, 3, 4, 5, 6]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>我们可以通过正常的迭代实现， 神奇的是， 使用reduce会更加简洁。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var arr = [[1, 2], [3, 4], [5, 6]]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var flattenedArray = arr.reduce((a, v) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return a.concat(v)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}, [])</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">flattenedArray // (6) [1, 2, 3, 4, 5, 6]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="93-filter"></a>9.3 filter<a class="hash-link" href="#93-filter" title="Direct link to heading">#</a></h3><p>filter与map更为接近， 对数组的每个元素进行操作并返回另外一个数组（不同于reduce返回的值）。过滤后的数组可能比原数组长度更短。因为， 我们通过的可能排除 输出数组中更少/零的输入。
filter执行如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">arr.filter((v) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Boolean;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>v是数组中的元素， 通过true/false表示过滤元素包括/排除。假设， 我们过滤出以t开始以r结束的元素。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var words = [&quot;tiger&quot;, &quot;toast&quot;, &quot;boat&quot;, &quot;tumor&quot;, &quot;track&quot;, &quot;bridge&quot;]</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var newData = words.filter((str) =&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return str.startsWith(&#x27;t&#x27;) &amp;&amp; str.endsWith(&#x27;r&#x27;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">newData // (2) [&quot;tiger&quot;, &quot;tumor&quot;]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>当你被问到js方面的问题时， 这三个函数应该信手拈来。如你所看到的， 所有三个函数例子并没有改变原数组， 这也证明了这些函数的纯净性。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="10-熟悉错误异常处理模式"></a>10. 熟悉错误(异常)处理模式<a class="hash-link" href="#10-熟悉错误异常处理模式" title="Direct link to heading">#</a></h2><p>这部分是许多开发者最不关系的js部分。我了解到很少开发人员讨论错误处理。好的开发方法是小心的将js代码包裹在try/catch周围。</p><p>Nicholas C. Zakas， 雅虎的UI工程师， 2018 说过： “经常假设你的代码会失败。事件处理可能不当。记录到服务器。抛出你自己的问题。”</p><p>js中， 我们随意码的代码， 可能失败， 如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">$(&#x27;button&#x27;).click(function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    $.ajax({</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        url: &#x27;user.json&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        success: function(res) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            updateUI(res[&#x27;posts&#x27;]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>此时， 我们落入ajax结果总是JSON对象的陷阱。有时， 服务器会崩溃并返回null。这种情况下， null[&quot;posts&quot;]会抛出错误。正确的处理方式如下：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">$(&#x27;button&#x27;).click(function() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    $.ajax({</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        url: &#x27;user.json&#x27;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        success: function(res) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                updateUI(res[&#x27;posts&#x27;]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            catch(e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                logError();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                flashInfoMessage();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>logError函数打算向服务器报告错误。</li><li>flashInfoMessage函数使用“当前服务器不可用”等用户友好型方式展示错误信息。</li></ul><p>Nicholas说过， 当你感到不可预期的事情发生时手动抛出错误。区分致命和非致命错误。上面的错误与后台服务器挂机相关，是致命的。因此， 我们应该通知客户服务器因为一些原因挂机。这种情况下， 不是致命的， 但是最好通知服务器。为了创建这样的代码， 首先抛出错误， 从window层级捕捉错误事件， 随后记录信息到服务器。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">reportErrorToServer = function(error) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    $.ajax({</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        type: &quot;POST&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        url: &quot;http://api.xyz.com/report&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        data: error,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        success: function(res) {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// window error evnet</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">window.addEvnetListener(&#x27;error&#x27;, function(e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    reportErrorToServer({</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        message: e.message</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function mainLogic() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new Error(&quot;error tip&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>这个代码需要做如下三件事：</p><ul><li>监听window层级错误</li><li>出现错误时， API记录</li><li>在服务器中记录</li></ul><p>你也可以使用新的Boolean函数（es5，es6）在程序之前监测变量的有效性并且不为null、undefined</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (Boolean()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // block code</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} else {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new Error(&quot;Custom message&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>始终考虑错误处理是你自己， 而不是浏览器。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="11-其他提升机制和事件冒泡"></a>11. 其他(提升机制和事件冒泡)<a class="hash-link" href="#11-其他提升机制和事件冒泡" title="Direct link to heading">#</a></h2><p>对于一个js开发者， 以上都是主要概念。了解少数内部细节可是非常有用的。js在浏览器中的工作机制。什么是提升机制和事件冒泡？</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="111-提升机制"></a>11.1 提升机制<a class="hash-link" href="#111-提升机制" title="Direct link to heading">#</a></h3><p>提升是  在代码执行过程中将声明的变量推送到程序顶部 的一个过程。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">function doSomething(v) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">doSomething(foo);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var foo;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>使用脚本语言类似Python执行以上程序， 会抛出错误。你需要先定义再使用。虽然js是脚本语言， 但是它有提升机制。 在这种机制中， 一个js VM在运行程序是做了以下两件事：</p><ul><li>首先，扫描程序收集所有变量和函数的声明和分配内存空间。</li><li>通过填充分配的变量来执行程序， 没有分配则填充undefined</li></ul><p>以上代码片段中打印“undefined”， 因为最初的扫描中已经收集了变量foo。VM查找所有foo的值。</p><p>在 一些地方回抛出错误 和 另外地方使用undefined js环境下的提升机制。学习<a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" target="_blank" rel="noopener noreferrer">一些例子</a>来搞清楚提升。</p><blockquote><p>author: 声明可以被提升， 赋值不会。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="112-事件冒泡"></a>11.2 事件冒泡<a class="hash-link" href="#112-事件冒泡" title="Direct link to heading">#</a></h3><p>关于事件冒泡， 依据Arun P（ 一个高级软件工程）所描述：</p><blockquote><p>“事件冒泡和捕获在HTML DOM API中事件传播的两种方式，当同时注册事件的父子元素中子元素触发事件时。事件的传播方式决定接受事件的元素顺序 ”</p></blockquote><p>关于冒泡， 事件最先由内部元素捕获和处理， 随后传递给父级元素。关于捕获， 顺序相反。我们通常使用addEventListener函数来捆绑事件和事件处理函数</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">addEventListener(&#x27;click&#x27;, handler, useCapture=false);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>useCapture是第三个参数的关键词， 默认为false。因此， 冒泡模式是事件由底部向上传递。 反之， 这是捕获模式。</p><p>冒泡模式：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;div onClick=&quot;divHandler()&quot;&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;ul onClick=&quot;ulHandler()&quot;&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &lt;li id=&quot;foo&quot;&gt;&lt;/li&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;/ul&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;/div&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;script&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function handler() {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function divHandler() {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">function ulHandler() {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">documnet.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, handler)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&lt;/script&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>点击li元素， 事件顺序：<code>handler() =&gt; ulHandler() =&gt; divHandler()</code></p><p>捕获模式：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, handler, true)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>点击li元素， 事件顺序<code>divHandler =&gt; ulHandler() =&gt; handler()</code></p><p>以上都是基础的js知识。 正如我最初提及的， 除了这些， 工作经历和知识、准备对你攻克面试都有帮助。保持学习的习惯， 学习最新得技术(es6)， 深入js各个方面的学习(如V6、测试等)。一些视频也可以教会你一些知识。最后， 数据结构和算法的准备也必不可少。<a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener noreferrer">Oleksii Trekhleb 的算法仓库值得学习</a></p><p><a href="https://medium.com/dev-bits/a-perfect-guide-for-cracking-a-javascript-interview-a-developers-perspective-23a5c0fa4d0d" target="_blank" rel="noopener noreferrer">阅读原文</a></p></div><footer class="row margin-vert--lg"><div class="col"><strong>Tags:</strong><a class="margin-horiz--sm" href="/blog/tags/javascript面试">javascript面试</a></div></footer></article><div><a href="https://github.com/zhaocchen/zhaocchen.github.io/blob/master/blog/2018-10-20-译-攻破javascript面试的完美指南.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/最近使用的几种图标字体库"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« 最近使用的几种图标字体库</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/译-雅虎35条军规"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">译-提升页面性能的最好实践(雅虎35条军规) »</div></a></div></nav></div></main><div class="col col--2"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#0-前言" class="table-of-contents__link">0. 前言</a></li><li><a href="#1熟悉js函数" class="table-of-contents__link">1.熟悉js函数</a></li><li><a href="#2熟悉bind、apply和call" class="table-of-contents__link">2.熟悉bind、apply和call</a><ul><li><a href="#一个应急调用实例" class="table-of-contents__link">一个应急调用实例</a></li></ul></li><li><a href="#3熟悉js作用域闭包" class="table-of-contents__link">3.熟悉js作用域(闭包)</a></li><li><a href="#4熟悉this全局域、函数域、对象域" class="table-of-contents__link">4.熟悉this(全局域、函数域、对象域)</a></li><li><a href="#5熟悉对象freeze、seal属性" class="table-of-contents__link">5.熟悉对象(freeze、seal属性)</a></li><li><a href="#6熟悉原型继承" class="table-of-contents__link">6.熟悉原型继承</a></li><li><a href="#7熟悉callback和promise" class="table-of-contents__link">7.熟悉callback和promise</a></li><li><a href="#8熟悉正则表达" class="table-of-contents__link">8.熟悉正则表达</a></li><li><a href="#9熟悉map、reduce和filter" class="table-of-contents__link">9.熟悉map、reduce和filter</a><ul><li><a href="#91-map" class="table-of-contents__link">9.1 map</a></li><li><a href="#92-reduce" class="table-of-contents__link">9.2 reduce</a></li><li><a href="#93-filter" class="table-of-contents__link">9.3 filter</a></li></ul></li><li><a href="#10-熟悉错误异常处理模式" class="table-of-contents__link">10. 熟悉错误(异常)处理模式</a></li><li><a href="#11-其他提升机制和事件冒泡" class="table-of-contents__link">11. 其他(提升机制和事件冒泡)</a><ul><li><a href="#111-提升机制" class="table-of-contents__link">11.1 提升机制</a></li><li><a href="#112-事件冒泡" class="table-of-contents__link">11.2 事件冒泡</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">专栏</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">开始阅读</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">社区</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">更多</h4><ul class="footer__items"><li class="footer__item"><a href="https://doocs.github.io/leetcode/#/" target="_blank" rel="noopener noreferrer" class="footer__link-item">LeedCode题解</a></li><li class="footer__item"><a href="https://github.com/zhaocchen" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/styles.c8a50b90.js"></script>
<script src="/assets/js/runtime~main.e3a5b9b1.js"></script>
<script src="/assets/js/main.7b4fe14a.js"></script>
<script src="/assets/js/1.8bed503c.js"></script>
<script src="/assets/js/2.9d62b940.js"></script>
<script src="/assets/js/3.eab559b0.js"></script>
<script src="/assets/js/ccc49370.76f47225.js"></script>
<script src="/assets/js/694019e6.819dc3e7.js"></script>
<script src="/assets/js/81561cc0.419d6f73.js"></script>
</body>
</html>